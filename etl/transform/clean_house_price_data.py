import pandas as pd
import logging
from utils.file_utils import save_dataframe_to_csv
from utils.logging_utils import setup_logger
import time

# Configure the logger
logger = setup_logger(
    __name__,
    'extract_data.log',
    level=logging.DEBUG
)

# List of columns where missing values are fine
# An address does not need a Secondary Addressable Object Name
# or locality to be valid
COLUMNS_ALLOWED_TO_HAVE_NULL_VALUES = ['SAON', 'locality']

# Threshold percentage for dropping values to give a warning
WARNING_THRESHOLD = 10


def transform_house_price_data(house_price_data: pd.DataFrame) -> pd.DataFrame:

    cleaned_house_price_data = clean_data(house_price_data)

    enriched_house_price_data = enrich_data(cleaned_house_price_data)

    # Save the dataframe as a CSV for logging purposes
    save_dataframe_to_csv(enriched_house_price_data, "etl/data/processed/",
                          "cleaned_house_price_data.csv",)

    return enriched_house_price_data


def clean_data(house_price_data):
    start_time = time.time()

    # Parse all dates with pd.to_datetime. Coerce errors means it will put
    # a null value if parsing fails. Null values are removed later.
    house_price_data['date'] = pd.to_datetime(house_price_data['date'],
                                              errors='coerce')

    # Remove duplicates if any are present
    house_price_data.drop_duplicates(inplace=True)

    # Remove rows with missing values
    house_price_data = remove_missing_values(house_price_data)

    # Make new build column values into full words
    house_price_data['newbuild'] = house_price_data[
        'newbuild'].map({'Y': 'New build', 'N': 'Established'})

    # Make duration column values into full words
    house_price_data['duration'] = house_price_data[
        'duration'].map({'F': 'Freehold', 'L': 'Leasehold'})

    # Change property_type values to full names.
    type_map = {'D': 'Detached', 'S': 'Semi-Detached', 'T': 'Terraced',
                'F': 'Flats/Maisonettes', 'O': 'Other'}
    house_price_data['property_type'] = house_price_data[
        'property_type'].map(type_map)

    duration = time.time() - start_time
    logger.setLevel(logging.INFO)
    logger.info(f'Cleaned the data in {round(duration, 3)} seconds')

    return house_price_data


def enrich_data(house_price_data):
    start_time = time.time()

    # Put house prices into categories
    bins = [0, 250000, 500000, 750000, 1000000, 10000000, float('inf')]
    labels = ['Cheap', 'Affordable', 'Mid-range', 'High-end',
              'Millionaire Territory', 'Absolute Unit']
    house_price_data['house_price_category'] = pd.cut(
        house_price_data['price'], bins=bins, labels=labels)

    # Create a full_address column, by combining address elements together
    # If SAON is missing, it is omitted.
    # The aggregation code was generated by AI. The code I wrote for this
    # took around 50 seconds. I asked AI if it could be faster.
    address_components = ['PAON', 'SAON', 'street', 'city', 'postcode']
    house_price_data['full_address'] = house_price_data[
        address_components].fillna('').agg(lambda row: ', '.join(
            filter(None, map(str.strip, row))), axis=1)

    duration = time.time() - start_time
    logger.setLevel(logging.INFO)
    logger.info(f'Enriched the data in {round(duration, 3)} seconds')

    return house_price_data


def remove_missing_values(house_price_data):
    row_count = house_price_data.shape[0]

    for col in house_price_data.columns:
        if col not in COLUMNS_ALLOWED_TO_HAVE_NULL_VALUES:
            null_count = house_price_data[col].isna().sum()

            if null_count > 0:
                house_price_data = house_price_data.dropna(subset=col)
                percent_dropped = round(null_count / row_count * 100, 2)

                log_message = f'Dropped {null_count} ({percent_dropped}%)'
                log_message += f'rows with missing values in the {col} column.'

                if percent_dropped > WARNING_THRESHOLD:
                    logger.setLevel(logging.WARNING)
                    logger.warning(log_message)
                else:
                    logger.setLevel(logging.INFO)
                    logger.info(log_message)

    return house_price_data
